# 一:数组

### 1.两数之和:

```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

1. 方案一

   暴力遍历,如果相加的值相等则放进一个新的数组内

2. 方案二

   先对数组进行排序，再定义双指针，分别指向数组的开头和结尾，如果两者相加大于结果，则头指针++，否则尾指针--，直到头指针位置大于等于尾指针为止

3. 方案三

   利用map的数组结构，对数组中每个元素进行遍历，如果map中含有值为target减去当前item的key在的话，则get这个key，然后返回。如果没有的话，则将当前元素输入map（先判断后输入）

### 2.删除排序数组中的重复项：

```
给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
```

1. 方案一

   指定三个指针

   i：指向循环的每一个不同元素

   j：指向重复元素的下一个元素

   position：指向新元素的插入位置

````java
int i=0;
int j=0;
int potsion=i+1;
while(i<len){
    //j从i的下一个元素开始
	j=i+1;
    //一直循环，知道找到下一个非重复元素的开始位置
    while(j<len &&　nums[i]==nums[j]){
        j++;
    }
    if(j>len){
        break;
    }
    //插入新的元素
    nums[position]=nums[j];
    //插入位置增加
    position++;
    //当前元素改变为下一个不同元素
    i=j;
}

````

2. 方案二

   定义一个插入位置的标志index，for循环遍历数组，如果元素相同则无操作，如果不同则插入位置++，并将下标为插入位置的元素改为当前元素（这个更简单）


### 3.删除数组中的指定元素

1. 方案一

   同样是利用双指针，设定一个指针为插入位置，如果当前元素不等于要删除的元素，则指针位置++，并向原数组中插入元素


### 4.搜索插入位置

1. 方案一

   采用二分查找法，需要用到双指针，先对数组进行排序，使用while循环，当首指针位置小于等于尾指针时候进行循环，每次分两块进行查找

   ````java
   while(l<r){
   	m=l+(r-l)/2
       if(nums[m]=m){
           return m;
       }
       //这种情况一定能找到
       else if(nums[m]>m){
           r=m-1;
       }
       //这种情况不一定找到
       else{
           l=m+1;
       }
       //所以最后return l
       return l;
   }
   ````

### 5.最大子序和

​	````给定一个整数数组nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和 ````

1. 方案一

   for循环遍历这个数组，同时设定一个新的数组用来保存子元素的最大值，如果元素的指大于0，则新数组的值为新数组上一个元素的值+当前元素的值，然后再将max与当前元素进行比较

   ````java
   int max=nums[0];
   for(int i=1;i<len;i++){
       s[i] = (s[i-1]>0) ? nums[i]+s[i-1]: nums[i];
       max=Math.max(max,s[i]);
   }
   ````

### 6.加一

````
给定一个非负整数组成的非空数组，在该数的基础上加一，返回一个新的数组。

最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。
````

1. 方案一

   分情况讨论，一种情况是有进位，例如9变10，99变100，一种情况就是简单的加一

   遍历这个数组并进行+1操作，再遍历这个数组，如果有一个元素加一大于9的话，则该元素变为0，否则函数直接结束。

   如果有一个元素+1大于9，则新建一个数组，该数组的长度+1，且第一个元素为1，结束

### 7.合并两个有序数组

```
给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。

输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```

1. 方案一

   由于数组是排序数组，所以我们可以往第一个数组的最后端进行插入，分两种情况：A数组中的最后一个未插入元素小（大）于B数组的最后一个未插入元素。如果小于，则将B数组的最后一个未插入元素插入到A数组的最后一个未插入位置，否则则将A数组本身插入到A数组的最后一个未插入位置

   ````java
   nums1 = [1,2,3,0,0,0], m = 3
   nums2 = [2,5,6],       n = 3
   while(m>0 && n>0){
       if(A[m-1]>B[n-1]){
           A[m+n-1]=A[m-1];
           m--;
       }
       else{
           A[m+n-1]=B[n-1];
           n--;
       }
    //如果A数组中元素都很大，只是转移到后方,这样B数组中还有元素  
       while(n>0){
           A[n-1]=B[n-- -1];
       }
   }
   ````

   

   

   